#!/bin/bash

#Paths to Directories required for this pipeline:

bundle=${HOME}/bundle  #path to ref.hg38 (Homo_sapiens_assembly38.fasta),exome_capture_kit.bed,ref.hg38.interval_list (generated by gatk_cohort.sh),k100.umap.bed 
scatter=${bundle}/scatter
cohort_bams=${HOME}/bams # path to the COHORT input BAMs
cohort_tsv_files=${cohort_bams}/tsv_files # path to tsv_files generated by CollectReadCounts
output_dir=${HOME}/output_dir # path to the output directory
cohort_ploidy= ${output_dir}/cohort_ploidy
cohort_cnv_caller= ${output_dir}/cohort_cnv_caller
cohort_results=${output_dir}/cohort_results
gatk=${HOME}/gatk

# gatk PreprocessIntervals define the Read Counts Intervals. For exome,they are capture kit intervals
if [ ! -f ${bundle}/ref.hg38.interval_list ];then
	${gatk} PreprocessIntervals \
        	-R ${bundle}/Homo_sapiens_assembly38.fasta \
       		-L ${bundle}/exome_capture_kit.bed \
        	--padding 250 \
       		--bin-length 0 \
        	-imr OVERLAPPING_ONLY \
        	-O ${bundle}/ref.hg38.interval_list
else
        echo "CNVs PreprocessIntervals ready"
fi

# gatk CollectReadCounts collects the reads counts at each interval defined in the previous step.
if [ ! $(ls -A ${cohort_tsv_files}) ];then
for bam in ${cohort_bams}/*.bam;do
        ${gatk} CollectReadCounts \
                -L ${bundle}/ref.hg38.interval_list \
                -R ${bundle}/Homo_sapiens_assembly38.fasta \
                -imr OVERLAPPING_ONLY \
                -I $bam \
                --format TSV \
                -O ${cohort_tsv_files}/$(basename $bam .bam).tsv
done
else
	echo "CollectReadCounts ready"
fi

# gatk AnnotateIntervals annotates the previous Intervals for extreme GC content 
# and low mappability regions from https://bismap.hoffmanlab.org(k100.umap.bed: Unmap hg38 single-read)
if [ ! -f  ${bundle}/annotated_intervals.tsv ];then
        ${gatk} AnnotateIntervals \
                -R ${bundle}/Homo_sapiens_assembly38.fasta \
                -L ${bundle}/ref.hg38.interval_list \
                --mappability-track ${bundle}/k100.umap.bed \
                -imr OVERLAPPING_ONLY \
                -O ${bundle}/annotated_intervals.tsv
else
        echo "CNVs AnnotateInvervals ready"
fi

# gatk FilterIntervals filters the annotated Intervals for every sample's tsvfile Allosomes are also excluded from the analysis.
if [ ! -f ${bundle}/annotated_filtered.interval_list ];then
	${gatk} FilterIntervals \
		-L ${bundle}/ref.hg38.interval_list \
                --annotated-intervals ${bundle}/annotated_intervals.tsv \
		-I ${cohort_tsv_files}/sample1.tsv \
		-I ${cohort_tsv_files}/sample2.tsv \
		-I . \
		-i . \
		-I ${cohort_tsv_files}/samplen.tsv \
                --XL chrX --XL chrY \
		-imr OVERLAPPING_ONLY \
                -O ${bundle}/annotated_filtered.interval_list
else
        echo "FilterIntervals ready"
fi

# gatk DetermineGermlineContigPloidy calls chromosomal ploidy states for the COHORT and generates a model to used in CASE mode.
if [ ! -d  ${cohort_ploidy}/ploidy-calls ] && [ ! -d  ${cohort_ploidy}/ploidy-model ];then
	${gatk} DetermineGermlineContigPloidy \
        	-L ${bundle}/annotated_filtered.interval_list \
		--contig-ploidy-priors ${bundle}/hg38_contig_ploidy_priors.tsv \ #table containing the per-contig prior probabilities for integer ploidy state
                -I ${cohort_tsv_files}/sample1.tsv \
                -I ${cohort_tsv_files}/sample2.tsv \
                -I . \
                -I . \
                -I ${cohort_tsv_files}/samplen.tsv \
                -imr OVERLAPPING_ONLY \
        	-O ${cohort_ploidy}/ \
     		--output-prefix ploidy
else
       echo "CNVs DetermineGermlineContigPloidy ready"
fi

# gatk IntervalListTools lists the intervals included in the analysis shards. For this analysis,3 list with ~5K intervals each.
if [ ! $(ls -A ${scatter}) ];then
        ${gatk} IntervalListTools \
		-I ${bundle}/annotated_filtered.interval_list \
                --SUBDIVISION_MODE INTERVAL_COUNT \ #mode scatters intervals into similarly sized lists,based on the number of intervals from the first workflow step. 
                --SCATTER_CONTENT 50000 \
                -O ${scatter}
else
        echo "CNVs Scatter Intervals ready"
fi

# gatk GermlineCNVCaller trains a model per scattered shard, to be then applied on CASE, while calls CNV events in the COHORT.
if [ ! -d ${cohort_cnv_caller}/temp_0001_of_3-calls/ ] && [ ! -d ${cohort_cnv_caller}/temp_0001_of_3-model/ ] && [ ! -d ${cohort_cnv_caller}/temp_0001_of_3-tracking/ ] && [ ! -d ${cohort_cnv_caller}/temp_0002_of_3-calls/ ] && [ ! -d ${cohort_cnv_caller}/temp_0002_of_3-model/ ] && [ ! -d ${cohort_cnv_caller}/temp_0002_of_3-tracking/ ] && [ ! -d ${cohort_cnv_caller}/temp_0003_of_3-calls/ ] && [ ! -d ${cohort_cnv_caller}/temp_0003_of_3-model/ ] && [ ! -d ${cohort_cnv_caller}/temp_0003_of_3-tracking/ ];then
	for index in $(cat tempfile.txt);do  #tempfile is a file numbering the shards( 1..3)
                ${gatk} GermlineCNVCaller \
                        --run-mode COHORT \
                        -L ${scatter}/temp_000${index}_of_3/scattered.interval_list \
        	        -I ${cohort_tsv_files}/cohort/sample1.tsv \
                	-I ${cohort_tsv_files}/cohort/sample2.tsv \
                	-I . \
                	-I . \
                	-I . \
                	-I ${cohort_tsv_files}/cohort/samplen.tsv \
			-imr OVERLAPPING_ONLY \
	                --annotated-intervals ${bundle}/annotated_intervals.tsv \
                        --contig-ploidy-calls ${cohort_ploidy}/ploidy-calls \
                        -O ${cohort_cnv_caller} \
                        --output-prefix temp_000${index}_of_3
        done
else
	echo "CNVs GermlineCNVCaller ready"
fi

# gatk PostprocessGermlineCNVCalls calls the VCF files for each COHORT sample.  
if [ ! $(ls -A ${cohort_results}) ];then
        for index in $(cat cohort_file.txt);do #cohort_file is a file numbering COHORT(0..n-1),being n= number of COHORT samples
 
	${gatk} PostprocessGermlineCNVCalls \
                --model-shard-path ${cohort_cnv_caller}/temp_0001_of_3-model \ #the directory for each scatter of the cohort mode
                --model-shard-path ${cohort_cnv_caller}/temp_0002_of_3-model \
                --model-shard-path ${cohort_cnv_caller}/temp_0003_of_3-model \
                --calls-shard-path ${cohort_cnv_caller}/temp_0001_of_3-calls \ #the directory for each scatter of the cohort call
                --calls-shard-path ${cohort_cnv_caller}/temp_0002_of_3-calls \
                --calls-shard-path ${cohort_cnv_caller}/temp_0003_of_3-calls \
                --autosomal-ref-copy-number 2 \
                --allosomal-contig chrX --allosomal-contig chrY \
		--contig-ploidy-calls ${cohort_ploidy}/ploidy-calls \ #the directory for the COHORT analysis
                --sample-index $index \
                --output-genotyped-intervals ${cohort_results}/genotyped-intervals-cohort-normal-sample_${index}.vcf.gz \
                --output-genotyped-segments ${cohort_results}/genotyped-segments-cohort-normal-sample_${index}.vcf.gz \
                --output-denoised-copy-ratios sample_${index}_denoised_copy_ratios.tsv
        done
else
        echo  "CNVs PostprocessGermlineCNVCaller ready"
fi

